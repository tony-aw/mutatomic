[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2025). mutatomic: Tools Safe Pass--Reference Modification Semantics Atomic Objects. R package version 0.0.0.9.","code":"@Manual{,   title = {mutatomic: Tools for Safe Pass-by-Reference Modification Semantics on Atomic Objects},   author = {Tony Wilkes},   year = {2025},   note = {R package version 0.0.0.9}, }"},{"path":"/index.html","id":"mutatomic","dir":"","previous_headings":"","what":"Tools for Safe Pass-by-Reference Modification Semantics on Atomic Objects","title":"Tools for Safe Pass-by-Reference Modification Semantics on Atomic Objects","text":"mutatomic: Tools Safe Pass--Reference Modification Semantics Atomic Objects","code":""},{"path":"/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Tools for Safe Pass-by-Reference Modification Semantics on Atomic Objects","text":"Provides tools, including new class (‘mutatomic’), safe pass--reference modification semantics atomic objects. Primary purpose package ‘mutatomic’ class related tools accessible packages wish implement safe pass--reference semantics atomic objects.  ","code":""},{"path":"/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get Started","title":"Tools for Safe Pass-by-Reference Modification Semantics on Atomic Objects","text":"get started see ?mutatomic_help click .  ","code":""},{"path":"/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"Tools for Safe Pass-by-Reference Modification Semantics on Atomic Objects","text":"One can install ‘mutatomic’ GitHub like : One can attach package - thus exposing functions namespace - using:  ","code":"remotes::install_github(\"https://github.com/tony-aw/mutatomic\") library(mutatomic)"},{"path":"/reference/aaa00_mutatomic_help.html","id":null,"dir":"Reference","previous_headings":"","what":"mutatomic — aaa00_mutatomic_help","title":"mutatomic — aaa00_mutatomic_help","text":"Tools Safe Pass--Reference Modification Semantics Atomic Objects","code":""},{"path":"/reference/aaa00_mutatomic_help.html","id":"what-is-mutatomic-","dir":"Reference","previous_headings":"","what":"What is 'mutatomic'?","title":"mutatomic — aaa00_mutatomic_help","text":"'mutatomic' 'R' package provides 2 things: regular 'R' users:  new class atomic vectors, matrices, arrays, called mutatomic, provides (safer) support pass--reference semantics.  also provides optional helper function, called currentBindings. package back-end:  set tools safer pass--reference modification semantics atomic objects, 'R' natively provide pass--reference mechanics (except via internal C API package like 'Rcpp').  developer tools provided 'mutatomic' primarily designed 'squarebrackets' 'broadcast' packages, authors packages welcome use 'mutatomic' also. 'mutatomic' come pass--reference functions , except 2 simple example functions (ma_set setapply).","code":""},{"path":"/reference/aaa00_mutatomic_help.html","id":"for-regular-r-users","dir":"Reference","previous_headings":"","what":"For Regular 'R' Users","title":"mutatomic — aaa00_mutatomic_help","text":"Regular 'R' users can construct objects class 'mutatomic', convert objects class 'mutatomic';  see mutatomic_class.  Depending situation end users may also use currentBindings function.  'mutatomic' package also comes help pages, end users can refer , gain better understanding pass--reference semantics supported 'mutatomic'.  help pages following: mutatomic_class:  Explains 'mutatomic' class. mutatomic_PassByReference:  Explains Pass--Reference semantics, important consequences. mutatomic_coercion:  Explains difference coercion rules modification Pass--Reference semantics modification copy (.e. pass--value).","code":""},{"path":"/reference/aaa00_mutatomic_help.html","id":"for-package-back-end","dir":"Reference","previous_headings":"","what":"For Package Back-End","title":"mutatomic — aaa00_mutatomic_help","text":"'mutatomic' provides tools package authors program mutable atomic objects.  Arguably important function 'mutatomic' developers stopifnot_ma_safe2mutate function.  function checks atomic object safe mutate, gives error otherwise.  follows technical information 'mutatomic', 'mutatomic' class needed; interest regular 'R' users.","code":""},{"path":"/reference/aaa00_mutatomic_help.html","id":"technical-why-is-mutatomic-needed-","dir":"Reference","previous_headings":"","what":"Technical - Why is 'mutatomic' needed?","title":"mutatomic — aaa00_mutatomic_help","text":"Consider following code:   code modifies base::letters reference, nothing stopping user changing base 'R' 'R' still running!  Now, obviously collapse::setv() meant professional programmers, called amateurs.  one wishes design 'R' package provides pass--reference mechanics atomic objects safer way?  'mutatomic' package comes .  'mutatomic' provides new class can considered atomic version 'data.table' class, class package authors can protect user changing things like base:letters.","code":"x <- base::letters collapse::setv(x, \"a\", \"xxx\")"},{"path":"/reference/aaa00_mutatomic_help.html","id":"technical-how-does-mutatomic-solve-the-issue-","dir":"Reference","previous_headings":"","what":"Technical - How does 'mutatomic' solve the issue?","title":"mutatomic — aaa00_mutatomic_help","text":"'mutatomic' first fore-provides new class, called 'mutatomic'.  function demands atomic object class 'mutatomic' allow pass--reference semantics, issue (mostly) prevented.  issue prevented following means: Creating object class 'mutatomic', least using functions provided package, copy original object.  calling x <- mutatomic(base::letters), x longer refers base::letters. function demands object class 'mutatomic', (almost) guaranteed refer base 'R' object, something like base::letters never modified reference. 'mutatomic' stores list base 'R' (atomic) object addresses loaded.  .mutatomic stopifnot_ma_safe2mutate functions check list, creating extra certainty base 'R' never modified reference. 'mutatomic' class just defined class name attribute.  class comes additional attributes ensure truly created functions package.  Although attributes can mimicked enough effort, unlikely object accidentally attributes.  .mutatomic stopifnot_ma_safe2mutate functions check attributes, creating extra security. 'mutatomic' respects lock binding, .","code":""},{"path":"/reference/aaa00_mutatomic_help.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"mutatomic — aaa00_mutatomic_help","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":"/reference/aaa00_mutatomic_help.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mutatomic — aaa00_mutatomic_help","text":"Author, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'mutatomic' package.  \"Pass--reference\" refers modifying mutable object, subset mutable object, without making copies .  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'mutatomic' package ('data.table', 'squarebrackets', 'broadcast', ) word \"set\" name use pass--reference semantics.","code":""},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"main advantage pass--reference much less memory required modify objects, modification also generally faster.  several disadvantages.  First, coercion rules slightly different: see mutatomic_coercion.  Second, 2 variables refer exactly object (.e. address), changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutatomic(1:16) ma_set(x, 1:6, 8) x <- mutatomic(1:16) y <- x lockBinding(\"y\", environment()) ma_set(x, i = 1:6, rp = 8)"},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"mutable-vs-immutable-classes","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable Classes","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"exception environments, base R's S3 classes treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  prominent mutable S3 class data.table class, mutable data.frame class, supported 'mutatomic'.  Similarly, 'mutatomic' adds class mutable atomic objects: mutatomic.","code":""},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"material-vs-immaterial-objects","dir":"Reference","previous_headings":"","what":"Material vs Immaterial objects","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"objects 'R' material objects:  values object contains actually stored memory.  example, given x <- rnorm(1e6), x material object:  1 million values (decimal numbers, case) actually stored memory.  contrast, ActiveBindings immaterial:  objects , accessed, call function generate values fly, rather actually storing values.  Since immaterial objects actually store values memory, values obviously also changed memory.  Therefore, Pass--Reference semantics work immaterial objects.","code":""},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"altrep","dir":"Reference","previous_headings":"","what":"ALTREP","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"mutatomic constructors (.e. mutatomic, .mutatomic, etc.) automatically materialize ALTREP objects, ensure consistent behaviour 'pass--reference' semantics.  data.table can ALTREP columns.  data.tables coerce column materialized column modified, even reference.","code":""},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutatomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list mutatomic objects, example, mutatomic objects remain mutable.  Therefore, following pass--reference modification work without issue:   Notice code myref address x$, therefore copy x$.  Thus changing myref also changes x$.  words: myref called \"View\" x$.","code":"x <- list(  a = mutatomic(letters[1:10]),  b = mutatomic(letters[11:20]) ) myref <- x$a ma_set(myref, 1, \"xxx\")"},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"Methods/functions perform -place modification reference works objects actually exist actual variable, similar functions style some_function(x, ...) <- value.  Thus things like following, ma_set(1:10, ...), ma_set(x$, ...), ma_set(base::letters),  work.","code":""},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object mostly fruitless (completely; see currentBindings function).  ensure object modified methods/functions 'mutatomic', 2 things must true: object must immutable class. binding must locked (see lockBinding).","code":""},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"Due properties described help page, 'mutatomic' protects user something like following:   'mutatomic' give error running code , : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed.","code":"# letters = base::letters ma_set(letters, i = 1, rp = \"XXX\")"},{"path":"/reference/aaa01_mutatomic_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa01_mutatomic_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) myref <- x$a # view of a list address(myref) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"myref\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     ma_set(myref, 1, \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir)   is.mutatomic(myref) # ... because it's not of class `mutatomic` #> [1] FALSE   x <- list(   a = as.mutatomic(base::letters) # `as.mutatomic()` makes a copy ) myref <- x$a # view of a list address(myref) == address(base::letters) # FALSE: it's a copy #> [1] FALSE ma_set(   myref, i = 26, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"a\"   \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"XXX\" #> mutatomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""},{"path":"/reference/aaa02_mutatomic_coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules for Mutable Objects — aaa02_mutatomic_coercion","title":"Auto-Coercion Rules for Mutable Objects — aaa02_mutatomic_coercion","text":"help page describes auto-coercion rules mutable classes, handled 'mutatomic' package.  useful information users wish intend employ Pass--Reference semantics provided 'mutatomic'.","code":""},{"path":"/reference/aaa02_mutatomic_coercion.html","id":"mutatomic","dir":"Reference","previous_headings":"","what":"mutatomic","title":"Auto-Coercion Rules for Mutable Objects — aaa02_mutatomic_coercion","text":"Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also.","code":"x <- mutatomic(1:16) ma_set(x, i = 1:6, rp = 8.5) #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutatomic #> typeof:  integer"},{"path":"/reference/aaa02_mutatomic_coercion.html","id":"data-table-when-replacing-transforming-whole-columns","dir":"Reference","previous_headings":"","what":"data.table, when replacing/transforming whole columns","title":"Auto-Coercion Rules for Mutable Objects — aaa02_mutatomic_coercion","text":"data.table actually list made mutable, column list. , replacing/transforming whole columns using data.table::set(), without specifying rows (even = 1:nrow(x)), allows completely changing type column.","code":""},{"path":"/reference/aaa02_mutatomic_coercion.html","id":"data-table-when-partially-replacing-transforming-columns","dir":"Reference","previous_headings":"","what":"data.table, when partially replacing/transforming columns","title":"Auto-Coercion Rules for Mutable Objects — aaa02_mutatomic_coercion","text":"rows specified data.table::set() function (functions internally use data.table::set()), thus values columns parts(.e. rows) columns replaced, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  Using R's native copy--modify semantics (example changing data.table data.frame) allows coercion even partially replacing/transforming columns.","code":""},{"path":"/reference/aaa02_mutatomic_coercion.html","id":"views-of-lists","dir":"Reference","previous_headings":"","what":"Views of Lists","title":"Auto-Coercion Rules for Mutable Objects — aaa02_mutatomic_coercion","text":"Regular lists treated immutable 'mutatomic'.  remember list (potentially hierarchical) structure references objects.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code myref copy x$, since address.  Thus changing myref also changes x$.  words: myref called \"view\" x$.  Notice also ma_set(x$, ...) work.  stopifnot_ma_safe2mutate give error x actual variable, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus View data.table, coercion rules data.tables apply.  View mutatomic object, coercion rules mutatomic objects apply, etc.","code":"x <- list(  a = mutatomic(letters[1:10]),  b = mutatomic(letters[11:20]) ) myref <- x$a ma_set(myref, 1, \"xxx\")"},{"path":"/reference/aaa02_mutatomic_coercion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-Coercion Rules for Mutable Objects — aaa02_mutatomic_coercion","text":"","code":"# Coercion examples - mutatomic ====  x <- as.mutatomic(1:16) ma_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutatomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   data.table::set(   obj, j = c(\"a\", \"c\"),   value = -1 # SAFE: row=NULL & obs = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  data.table::set(   obj, i = which(with(obj, (a >= 2) & (c <= 17))), j = c(\"a\", \"c\"),   value = -1   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:    -1      b    -1      b #>  3:    -1      c    -1      c #>  4:    -1      d    -1      d #>  5:    -1      e    -1      e #>  6:    -1      f    -1      f #>  7:    -1      g    -1      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j    #############################################################################  # View of List ====  x <- list(   a = mutatomic(letters[1:10]),   b = mutatomic(letters[11:20]) ) myref <- x$a ma_set(myref, 1L, \"xxx\") print(x) #> $a #>  [1] \"xxx\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   #> mutatomic  #> typeof:  character  #>  #> $b #>  [1] \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> mutatomic  #> typeof:  character  #>  myref <- x$a address(myref) == address(x$a) # they are the same #> [1] TRUE print(x) # notice x has been changed #> $a #>  [1] \"xxx\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   #> mutatomic  #> typeof:  character  #>  #> $b #>  [1] \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> mutatomic  #> typeof:  character  #>"},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'mutatomic' package.  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'mutatomic' package word \"set\" name use pass--reference semantics.","code":""},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"main advantage pass--reference much less memory required modify objects, modification also generally faster.  several disadvantages.  First, coercion rules slightly different: see mutatomic_coercion.  Second, 2 variables refer exactly object, changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutatomic(1:16) ma_set(x, 1:6, 8) x <- mutatomic(1:16) y <- x lockBinding(\"y\", environment()) ma_set(x, i = 1:6, rp = 8)"},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"mutable-vs-immutable-classes","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable Classes","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"exception environments, base R's S3 classes treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  prominent mutable S3 class data.table class, mutable data.frame class, supported 'mutatomic'.  Similarly, 'mutatomic' adds class mutable atomic objects: mutatomic.","code":""},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"material-vs-immaterial-objects","dir":"Reference","previous_headings":"","what":"Material vs Immaterial objects","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"objects 'R' material objects:  values object contains actually stored memory.  example, given x <- rnorm(1e6), x material object:  1 million values (decimal numbers, case) actually stored memory.  contrast, ActiveBindings immaterial:  objects , accessed, call function generate values fly, rather actually storing values.  Since immaterial objects actually store values memory, values obviously also changed memory.  Therefore, Pass--Reference semantics work immaterial objects.","code":""},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"altrep","dir":"Reference","previous_headings":"","what":"ALTREP","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"mutatomic constructors (.e. mutatomic, .mutatomic, etc.) automatically materialize ALTREP objects, ensure consistent behaviour 'pass--reference' semantics.  data.table can ALTREP columns.  data.tables coerce column materialized column modified, even reference.","code":""},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutatomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list mutatomic objects, example, mutatomic objects remain mutable.  Therefore, following pass--reference modification work without issue:   Notice code myref address x$, therefore copy x$.  Thus changing myref also changes x$.  words: myref called \"View\" x$.","code":"x <- list(  a = mutatomic(letters[1:10]),  b = mutatomic(letters[11:20]) ) myref <- x$a ma_set(myref, 1, \"xxx\")"},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"Methods/functions perform -place modification reference works objects actually exist actual variable, similar functions style some_function(x, ...) <- value.  Thus things like following, ma_set(1:10, ...), ma_set(x$, ...), ma_set(base::letters),  work.","code":""},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object mostly fruitless (completely; see currentBindings function).  ensure object modified methods/functions 'mutatomic', 2 things must true: object must immutable class. binding must locked (see lockBinding).","code":""},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"Due properties described help page, 'mutatomic' protects user something like following:   'mutatomic' give error running code , : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed.","code":"# letters = base::letters ma_set(letters, i = 1, rp = \"XXX\")"},{"path":"/reference/aaa02_mutatomic_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa02_mutatomic_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) myref <- x$a # view of a list address(myref) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"myref\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     ma_set(myref, 1, \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir)   is.mutatomic(myref) # ... because it's not of class `mutatomic` #> [1] FALSE   x <- list(   a = as.mutatomic(base::letters) # `as.mutatomic()` makes a copy ) myref <- x$a # view of a list address(myref) == address(base::letters) # FALSE: it's a copy #> [1] FALSE ma_set(   myref, i = 26, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"a\"   \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"XXX\" #> mutatomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""},{"path":"/reference/aaa03_mutatomic_coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules for Mutable Objects — aaa03_mutatomic_coercion","title":"Auto-Coercion Rules for Mutable Objects — aaa03_mutatomic_coercion","text":"help page describes auto-coercion rules mutable classes, handled 'mutatomic' package.  useful information users wish intend employ Pass--Reference semantics provided 'mutatomic'.","code":""},{"path":"/reference/aaa03_mutatomic_coercion.html","id":"mutatomic","dir":"Reference","previous_headings":"","what":"mutatomic","title":"Auto-Coercion Rules for Mutable Objects — aaa03_mutatomic_coercion","text":"Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also.","code":"x <- mutatomic(1:16) ma_set(x, i = 1:6, rp = 8.5) #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutatomic #> typeof:  integer"},{"path":"/reference/aaa03_mutatomic_coercion.html","id":"data-table-when-replacing-transforming-whole-columns","dir":"Reference","previous_headings":"","what":"data.table, when replacing/transforming whole columns","title":"Auto-Coercion Rules for Mutable Objects — aaa03_mutatomic_coercion","text":"data.table actually list made mutable, column list. , replacing/transforming whole columns, without specifying rows (even 1:nrow(x)), allows completely changing type column.","code":""},{"path":"/reference/aaa03_mutatomic_coercion.html","id":"data-table-when-partially-replacing-transforming-columns","dir":"Reference","previous_headings":"","what":"data.table, when partially replacing/transforming columns","title":"Auto-Coercion Rules for Mutable Objects — aaa03_mutatomic_coercion","text":"rows specified data.table::set() function, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  Treating data.table regular data.frame, however, allows coercion just like regular data.frame objects.","code":""},{"path":"/reference/aaa03_mutatomic_coercion.html","id":"views-of-lists","dir":"Reference","previous_headings":"","what":"Views of Lists","title":"Auto-Coercion Rules for Mutable Objects — aaa03_mutatomic_coercion","text":"Regular lists treated immutable 'mutatomic'.  remember list (potentially hierarchical) structure references objects.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code myref copy x$, since address.  Thus changing myref also changes x$.  words: myref called \"view\" x$.  Notice also ma_set(x$, ...) work.  stopifnot_ma_safe2mutate give error x actual variable, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus View data.table, coercion rules data.tables apply.  View mutatomic matrix, coercion rules mutatomic matrices apply, etc.","code":"x <- list(  a = mutatomic(letters[1:10]),  b = mutatomic(letters[11:20]) ) myref <- x$a ma_set(myref, 1, \"xxx\")"},{"path":"/reference/aaa03_mutatomic_coercion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-Coercion Rules for Mutable Objects — aaa03_mutatomic_coercion","text":"","code":"# Coercion examples - mutatomic ====  x <- as.mutatomic(1:16) ma_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutatomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   data.table::set(   obj, j = c(\"a\", \"c\"),   value = -1 # SAFE: row=NULL & obs = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  data.table::set(   obj, i = which(with(obj, (a >= 2) & (c <= 17))), j = c(\"a\", \"c\"),   value = -1   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:    -1      b    -1      b #>  3:    -1      c    -1      c #>  4:    -1      d    -1      d #>  5:    -1      e    -1      e #>  6:    -1      f    -1      f #>  7:    -1      g    -1      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j    #############################################################################  # View of List ====  x <- list(   a = mutatomic(letters[1:10]),   b = mutatomic(letters[11:20]) ) myref <- x$a ma_set(myref, 1L, \"xxx\") print(x) #> $a #>  [1] \"xxx\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   #> mutatomic  #> typeof:  character  #>  #> $b #>  [1] \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> mutatomic  #> typeof:  character  #>  myref <- x$a address(myref) == address(x$a) # they are the same #> [1] TRUE print(x) # notice x has been changed #> $a #>  [1] \"xxx\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   #> mutatomic  #> typeof:  character  #>  #> $b #>  [1] \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> mutatomic  #> typeof:  character  #>"},{"path":"/reference/currentBindings.html","id":null,"dir":"Reference","previous_headings":"","what":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\")  lists currently existing objects sharing address x, given environment. currentBindings(x, action = \"checklock\")  searches currently existing objects sharing address x, given environment, reports locked locked. currentBindings(x, action = \"lock\")  searches currently existing objects sharing address x, given environment, locks using lockBinding.  See also mutatomic_PassByReference information regarding relation locked bindings pass--reference modifications.","code":""},{"path":"/reference/currentBindings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"currentBindings(x, action = \"list\", env = NULL)"},{"path":"/reference/currentBindings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"x existing variable whose address use searching bindings. action single string, giving action perform.  Must one following: \"list\" (default). \"checklock\". \"lock\". env environment look objects.  NULL (default), caller environment used.","code":""},{"path":"/reference/currentBindings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\"):  Returns character vector.  currentBindings(x, action = \"checklock\"):  Returns named logical vector.  names give names bindings,  associated value indicates whether binding locked (TRUE) locked (FALSE).  currentBindings(x, action = \"lock\"):  Returns VOID. just locks currently existing bindings.  unlock bindings, remove objects (see rm).","code":""},{"path":"/reference/currentBindings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"lockBinding function locks binding object, preventing modification.  'R' also uses locked bindings prevent modification objects package namespaces.  'mutatomic principle respect , disallows modification objects reference.  However, lockBinding lock address/pointer object, one particular binding object.  problematic; consider following example:   code, x y share address, thus pointing memory, yet y actually locked.  Since x locked, modifying x allowed.  since ma_set() performs modification reference, y still modified, despite locked.  currentBindings() function allows user : find currently existing bindings caller environment sharing address x, locking bindings.","code":"x <- mutatomic(1:16) y <- x lockBinding(\"y\", environment()) ma_set(x, i = 1:6, rp = 8)"},{"path":"/reference/currentBindings.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings() function locks currently existing bindings specified environment;  bindings created calling currentBindings() automatically locked.  Thus, every time user creates new binding object, user wishes locked, currentBindings() must called .","code":""},{"path":"/reference/currentBindings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"x <- as.mutatomic(1:10) y <- x lockBinding(\"y\", environment()) currentBindings(x) #> searching environment: <000002620fdac828> #> [1] \"x\" \"y\" currentBindings(x, \"checklock\") # only y is locked #> searching environment: <000002620fdac828> #>     x     y  #> FALSE  TRUE    # since only y is locked, we can still modify y through x by reference: ma_set(x, i = 1, rp = -1) #> coercing replacement to integer print(y) # modified! #>  [1] -1  2  3  4  5  6  7  8  9 10 #> mutatomic  #> typeof:  integer  rm(list= c(\"y\")) # clean up   # one can fix this by locking ALL bindings: y <- x currentBindings(x, \"lock\") # lock all #> searching environment: <000002620fdac828> currentBindings(x, \"checklock\") # all bindings are locked, including y #> searching environment: <000002620fdac828> #>    x    y  #> TRUE TRUE  # the 'mutatomic' package respects the lock of a binding, # provided all bindings of an address are locked; # so this will give an error, as it should:  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     ma_set(x, i = 1, rp = -1),     pattern = \"cannot change value of locked binding for\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir)   # creating a new variable will NOT automatically be locked: z <- y # new variable; will not be locked! currentBindings(x, \"checklock\") # z is not locked #> searching environment: <000002620fdac828> #>     x     y     z  #>  TRUE  TRUE FALSE  currentBindings(x, \"lock\") # we must re-run this #> searching environment: <000002620fdac828> currentBindings(x, \"checklock\") # now z is also locked #> searching environment: <000002620fdac828> #>    x    y    z  #> TRUE TRUE TRUE   if(requireNamespace(\"tinytest\")) {   tinytest::expect_error( # now z is also protected     ma_set(z, i = 1, rp = -1),     pattern = \"cannot change value of locked binding for\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir)    rm(list= c(\"x\", \"y\", \"z\")) # clean up"},{"path":"/reference/developer.html","id":null,"dir":"Reference","previous_headings":"","what":"Exposed functions for Package developers — .internal_set_ma","title":"Exposed functions for Package developers — .internal_set_ma","text":"Functions developers.  functions list called regular users.  used inside packages.","code":""},{"path":"/reference/developer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exposed functions for Package developers — .internal_set_ma","text":"","code":".internal_set_ma(x)"},{"path":"/reference/developer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exposed functions for Package developers — .internal_set_ma","text":"x atomic object","code":""},{"path":"/reference/developer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exposed functions for Package developers — .internal_set_ma","text":"Returns: VOID. function modifies object reference.  use assignment like x <- .internal_set_ma(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"/reference/developer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Exposed functions for Package developers — .internal_set_ma","text":".internal_set_ma() sets object class 'mutatomic' reference.","code":""},{"path":"/reference/developer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exposed functions for Package developers — .internal_set_ma","text":"","code":"testfun1 <- function(x) {   .internal_set_ma(x) }   x <- 1:10 is.mutatomic(x) #> [1] FALSE  testfun1(x) is.mutatomic(x) #> [1] TRUE print(x) #>  [1]  1  2  3  4  5  6  7  8  9 10 #> mutatomic  #> typeof:  integer"},{"path":"/reference/ma_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Pass-By-Reference Function — ma_set","title":"Example Pass-By-Reference Function — ma_set","text":"ma_set() function modifies subset mutatomic object reference.  example function, used illustrate various examples help pages.  full pass--reference functionality, please see - example - 'squarebrackets' package.","code":""},{"path":"/reference/ma_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Pass-By-Reference Function — ma_set","text":"","code":"ma_set(x, i, rp)"},{"path":"/reference/ma_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Example Pass-By-Reference Function — ma_set","text":"x mutatomic vector (also works arrays). vector strictly positive numbers, providing vector indices. rp replacement value.  Must type x, length lenght 1.","code":""},{"path":"/reference/ma_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Example Pass-By-Reference Function — ma_set","text":"Returns: VOID. method modifies object reference.  use assignments like x <- ma_set(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"/reference/ma_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example Pass-By-Reference Function — ma_set","text":"","code":"x <- as.mutatomic(1:16) ma_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutatomic  #> typeof:  integer"},{"path":"/reference/mutatomic_class.html","id":null,"dir":"Reference","previous_headings":"","what":"A Class of Mutable Atomic Objects — mutatomic_class","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"package overview, see mutatomic_help.  mutatomic class mutable version atomic classes.  works exactly aspects regular atomic classes.  one real difference:  Pass--reference functions (primarily) 'squarebrackets' 'broadcast' packages accept atomic objects class mutatomic, greater safety.  aspects, mutatomic objects R's regular atomic objects, including behaviour [<- operator .  Exposed functions (beside S3 methods): mutatomic(): create mutatomic object given data. couldb.mutatomic(): checks object become mutatomic.  objects can become mutatomic one following types: logical, integer, double, character, complex, raw.  Factors can never mutatomic. setas.mutatomic(): set large long vectors/arrays class mutatomic reference.  work ALTREP objects.","code":""},{"path":"/reference/mutatomic_class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"","code":"mutatomic(data, names = NULL, dim = NULL, dimnames = NULL)  as.mutatomic(x, ...)  setas.mutatomic(x, ...)  is.mutatomic(x)  couldb.mutatomic(x)"},{"path":"/reference/mutatomic_class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"data atomic vector giving data fill mutatomic object. names, dim, dimnames see setNames array. x atomic object. ... method dependent arguments.","code":""},{"path":"/reference/mutatomic_class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"mutatomic(), .mutatomic():  Returns mutatomic object.  .mutatomic():  Returns TRUE object mutatomic, returns FALSE otherwise.  couldb.mutatomic():  Returns TRUE object one following types: logical, integer, double, character, complex, raw.  Returns FALSE otherwise.","code":""},{"path":"/reference/mutatomic_class.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"Always use exported functions given 'mutatomic' create mutatomic object, make necessary checks.  Circumventing checks may break things!","code":""},{"path":"/reference/mutatomic_class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"","code":"x <- mutatomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutatomic  #> typeof:  integer   x <- matrix(1:10, ncol = 2) x <- as.mutatomic(x) is.mutatomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutatomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutatomic  #> typeof:  integer  x[] <- as.double(x) #> coercing type from `integer` to `double` print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutatomic  #> typeof:  double  is.mutatomic(x) #> [1] TRUE"},{"path":"/reference/mutatomic_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"'mutatomic' Method Extension of Generic Functions — mutatomic_methods","title":"'mutatomic' Method Extension of Generic Functions — mutatomic_methods","text":"page lists methods defined mutatomic class.  package overview, see mutatomic_help.","code":""},{"path":"/reference/mutatomic_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"'mutatomic' Method Extension of Generic Functions — mutatomic_methods","text":"","code":"# S3 method for class 'mutatomic' as.logical(x, ...)  # S3 method for class 'mutatomic' as.integer(x, ...)  # S3 method for class 'mutatomic' as.double(x, ...)  # S3 method for class 'mutatomic' as.complex(x, ...)  # S3 method for class 'mutatomic' as.character(x, ...)  # S3 method for class 'mutatomic' as.raw(x, ...)  # S3 method for class 'mutatomic' c(..., use.names = TRUE)  # S3 method for class 'mutatomic' x[...]  # S3 method for class 'mutatomic' x[...] <- value  # S3 method for class 'mutatomic' format(x, ...)  # S3 method for class 'mutatomic' print(x, ...)"},{"path":"/reference/mutatomic_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"'mutatomic' Method Extension of Generic Functions — mutatomic_methods","text":"x atomic object. ... method dependent arguments. use.names Boolean, indicating names preserved. value see Extract.","code":""},{"path":"/reference/mutatomic_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"'mutatomic' Method Extension of Generic Functions — mutatomic_methods","text":"Returns, modifies, prints mutatomic object.","code":""},{"path":"/reference/mutatomic_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"'mutatomic' Method Extension of Generic Functions — mutatomic_methods","text":"","code":"x <- mutatomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutatomic  #> typeof:  integer   x <- matrix(1:10, ncol = 2) x <- as.mutatomic(x) is.mutatomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutatomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutatomic  #> typeof:  integer  x[] <- as.double(x) #> coercing type from `integer` to `double` print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutatomic  #> typeof:  double  is.mutatomic(x) #> [1] TRUE"},{"path":"/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table address, copy","code":""},{"path":"/reference/safe2mutate.html","id":null,"dir":"Reference","previous_headings":"","what":"Check If an Atomic Object is Safe to Mutate — stopifnot_ma_safe2mutate","title":"Check If an Atomic Object is Safe to Mutate — stopifnot_ma_safe2mutate","text":"Arguably important function 'mutatomic' package development stopifnot_ma_safe2mutate() function, checks atomic object actually safe mutate.  Package authors wish use 'mutatomic' pass--reference semantics check atomic object safe mutate using stopifnot_ma_safe2mutate() function;  otherwise things might break 'R'.","code":""},{"path":"/reference/safe2mutate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check If an Atomic Object is Safe to Mutate — stopifnot_ma_safe2mutate","text":"","code":"stopifnot_ma_safe2mutate(sym, envir, .abortcall)"},{"path":"/reference/safe2mutate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check If an Atomic Object is Safe to Mutate — stopifnot_ma_safe2mutate","text":"sym symbol object; .e. substitute(x). envir environment object resides; .e. parent.frame(n = 1). .abortcall environment error message passed .","code":""},{"path":"/reference/safe2mutate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check If an Atomic Object is Safe to Mutate — stopifnot_ma_safe2mutate","text":"Nothing. gives error object safe mutate.","code":""},{"path":"/reference/safe2mutate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check If an Atomic Object is Safe to Mutate — stopifnot_ma_safe2mutate","text":"","code":"x <- 1:16  testfun <- function(x) {   stopifnot_ma_safe2mutate(substitute(x), parent.frame(n = 1), sys.call()) }  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     testfun(x),     pattern = \"not a 'mutatomic' object\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir)   mylist <- list(   a = mutatomic(1:10) )  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     testfun(mylist$a),     pattern = \"only objects that exist as variables can be modified by reference\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir)   lockBinding(\"x\", environment())  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     testfun(x),     pattern = \"cannot change value of locked binding for\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir)    rm(list = \"x\")"},{"path":"/reference/setapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Functions Over mutatomic Matrix Margins By Reference — setapply","title":"Apply Functions Over mutatomic Matrix Margins By Reference — setapply","text":"setapply() function applies functions rows columns mutatomic matrix, pass--reference semantics.  setapply() bit faster uses less memory apply.","code":""},{"path":"/reference/setapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Functions Over mutatomic Matrix Margins By Reference — setapply","text":"","code":"setapply(x, MARGIN, FUN)"},{"path":"/reference/setapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Functions Over mutatomic Matrix Margins By Reference — setapply","text":"x mutatomic 2-dimensional array (.e. matrix).  Arrays 2 dimensions supported. MARGIN single integer scalar, giving subscript apply function . 1 indicates rows, 2 indicates columns. FUN function applied.  function must return vector type x, appropriate length (.e. length ncol(x) MARGIN == 1 length nrow(x) MARGIN == 2).","code":""},{"path":"/reference/setapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Functions Over mutatomic Matrix Margins By Reference — setapply","text":"Returns: VOID. function modifies object reference.  use assignment like x <- setapply(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"/reference/setapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Functions Over mutatomic Matrix Margins By Reference — setapply","text":"","code":"# re-order elements matrix by reference ==== x <- mutatomic::mutatomic(1:20, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 #> mutatomic  #> typeof:  integer  setapply(x, 1, FUN = \\(x)x[c(4,1,3,2)]) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16    1   11    6 #> [2,]   17    2   12    7 #> [3,]   18    3   13    8 #> [4,]   19    4   14    9 #> [5,]   20    5   15   10 #> mutatomic  #> typeof:  integer    # sort elements of matrix by reference ==== x <- mutatomic::mutatomic(20:1, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   20   15   10    5 #> [2,]   19   14    9    4 #> [3,]   18   13    8    3 #> [4,]   17   12    7    2 #> [5,]   16   11    6    1 #> mutatomic  #> typeof:  integer  setapply(x, 2, FUN = sort) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16   11    6    1 #> [2,]   17   12    7    2 #> [3,]   18   13    8    3 #> [4,]   19   14    9    4 #> [5,]   20   15   10    5 #> mutatomic  #> typeof:  integer"}]
